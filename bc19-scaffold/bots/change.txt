diff --git a/28.SeedBot/castles.py b/28b.CrusaderBot_for_analysis/castles.py
index bfc8565..8fa9ae7 100644
--- a/28.SeedBot/castles.py
+++ b/28b.CrusaderBot_for_analysis/castles.py
@@ -50,6 +50,7 @@ def castle(robot):
 def _castle_initial_check(robot):
     my_x = robot.me['x']
     my_y = robot.me['y']
+    robot.log(str((my_x, my_y)))
     if len(robot.fuel_mine_locations_from_this_castle) == 0:
         unused_store, robot.fuel_mine_locations_from_this_castle = utility.get_sorted_list_from_a_point(my_x, my_y, mapping.get_friendly_fuel(robot))
         robot.fuel_mine_occupancy_from_this_castle = [-1 for i in range(len(robot.fuel_mine_locations_from_this_castle))]
diff --git a/28.SeedBot/check.py b/28b.CrusaderBot_for_analysis/check.py
index 2b690b5..33f6757 100644
--- a/28.SeedBot/check.py
+++ b/28b.CrusaderBot_for_analysis/check.py
@@ -22,7 +22,9 @@ def move_check(robot, dx, dy, flag):
             if robot.fuel >= constants.prophet_move_fuel_cost * distance:
                 return robot.move(dx, dy)
         else:
-            robot.log("Move check failed " +  str(flag))
+            # robot.log(constants.crusader_speed)
+            # robot.log(str(dx, dy))
+            # robot.log("Move check failed " +  str(flag))
             return None
     if robot.me.unit == constants.unit_preacher:
         if distance <= constants.prophet_speed:
diff --git a/28.SeedBot/churches.py b/28b.CrusaderBot_for_analysis/churches.py
index e62c972..6a25636 100644
--- a/28.SeedBot/churches.py
+++ b/28b.CrusaderBot_for_analysis/churches.py
@@ -16,7 +16,7 @@ def church(robot):
         return production_module.default_production_order(robot)
     elif robot.step > 250 and robot.karbonite > 100 and robot.fuel > 200:
         robot.signal(1, 2)
-        return churches_utility.church_build(robot, constants.unit_prophet)
+        return churches_utility.church_build(robot, constants.unit_crusader)
     else:
         None
         # self.log("Castle health: " + self.me['health'])
diff --git a/28.SeedBot/churches_utility.py b/28b.CrusaderBot_for_analysis/churches_utility.py
index 6ab2ba0..012154f 100644
--- a/28.SeedBot/churches_utility.py
+++ b/28b.CrusaderBot_for_analysis/churches_utility.py
@@ -9,6 +9,8 @@ def recieve_initial_signal(robot):
     for friendly_unit in friendly_units:
         if friendly_unit.unit == 2 and friendly_unit.signal > 0:
             _prophets_initial_check(robot, friendly_unit)
+        elif friendly_unit == 3 and friendly_unit.signal > 0:
+            _prophets_initial_check(robot, friendly_unit)
             break
 
 def _prophets_initial_check(robot, friendly_unit):
diff --git a/28.SeedBot/combat_module.py b/28b.CrusaderBot_for_analysis/combat_module.py
index 06a34bd..87e8e61 100644
--- a/28.SeedBot/combat_module.py
+++ b/28b.CrusaderBot_for_analysis/combat_module.py
@@ -92,6 +92,7 @@ def _prophet_combat(robot):
         else:
             # TRAVIS ATTACK CHECK 15
             return combat_utility.attack_location(robot, enemy_unit['x'], enemy_unit['y'], 15, fuel, enemy_unit)
+    return None
 
 def _crusader_combat(robot):
     # combat_utility.fill_combat_map(robot)
@@ -125,7 +126,7 @@ def _crusader_combat(robot):
         closest_pos = combat_utility.give_crusader_charge_location(robot, visible_enemy_list, visible_enemy_distance)
         if closest_pos != None:
             # TRAVIS MOVE CHECK 20
-            return check.move_check(robot, closest_pos[0], closest_pos[1], 20)
+            return check.move_check(robot, closest_pos[0] - robot.me.x, closest_pos[1] - robot.me.y, 20)
 
 def _preacher_combat(robot):
     combat_utility.fill_combat_map(robot)
diff --git a/28.SeedBot/crusaders.py b/28b.CrusaderBot_for_analysis/crusaders.py
index 26738ee..c63debf 100644
--- a/28.SeedBot/crusaders.py
+++ b/28b.CrusaderBot_for_analysis/crusaders.py
@@ -1,12 +1,18 @@
 import combat_module
+import constants
+import mapping
 import movement
 import tactics
+import vision
 
 def crusader(robot):
+    if robot.step == 0:
+        receive_initial_signal(robot)
 
-    prophet_attack_aggr_mode = combat_module.give_military_command(robot)
-    if prophet_attack_aggr_mode != None:
-        return prophet_attack_aggr_mode
+
+    crusader_attack_aggr_mode = combat_module.give_military_command(robot)
+    if crusader_attack_aggr_mode != None:
+        return crusader_attack_aggr_mode
 
     return crusader_move(robot)
 
@@ -14,3 +20,36 @@ def crusader_move(robot):
     if robot.current_move_destination != None and not movement.is_completely_surrounded(robot): #and tactics.should_combat_unit_be_at_battle_front(robot):
         return tactics.send_combat_unit_to_battle_front(robot, 0.35, 0.15)
     return 0
+
+def receive_initial_signal(robot):
+    unused_store, friendly_units = vision.sort_visible_friendlies_by_distance(robot)
+    for friendly_unit in friendly_units:
+        if friendly_unit.unit == 0 and friendly_unit.signal > 0:
+            robot.built_by_a_castle = 1
+            robot.built_by_a_church = 0
+            _crusader_initial_check(robot, friendly_unit)
+        elif friendly_unit.unit == 1 and friendly_unit.signal > 0:
+            robot.built_by_a_castle = 0
+            robot.built_by_a_church = 1
+            _crusader_initial_check(robot, friendly_unit)
+            break
+
+def _crusader_initial_check(robot, friendly_unit):
+
+    if robot.built_by_a_castle == 1:
+        robot.our_castle_or_church_base = (friendly_unit['x'], friendly_unit['y'])
+        robot.friendly_castles.append(robot.our_castle_or_church_base)
+    else:
+        robot.our_castle_or_church_base = (friendly_unit['x'], friendly_unit['y'])
+        robot.friendly_churches.append(robot.our_castle_or_church_base)
+
+    if robot.crusader_health == None:
+        robot.crusader_health = constants.crusader_max_health
+
+    if robot.map_symmetry == None:
+        mapping.return_map_symmetry(robot)
+
+    if len(robot.enemy_castles) == 0 and robot.built_by_a_castle == 1:
+        robot.enemy_castles.append(mapping.find_symmetrical_point(robot, friendly_unit['x'], friendly_unit['y'], robot.map_symmetry))
+
+    robot.current_move_destination = mapping.find_symmetrical_point(robot, robot.our_castle_or_church_base[0], robot.our_castle_or_church_base[1], robot.map_symmetry)
diff --git a/28.SeedBot/production_module.py b/28b.CrusaderBot_for_analysis/production_module.py
index 291a1a6..c8d1dc4 100644
--- a/28.SeedBot/production_module.py
+++ b/28b.CrusaderBot_for_analysis/production_module.py
@@ -52,9 +52,9 @@ def _build_manager_castle(robot):
         # Peaceful Conditions
         if robot.step >= 3:
             if robot.karbonite >= 15 and robot.fuel > 100 and pilgrim_count < (total_fuel + total_karbonite) * .35 and robot.step < 60:
-                if prophet_count < pilgrim_count/2:
+                if crusader_count < pilgrim_count/2:
                     robot.signal(1, 2)
-                    return castles_utility._castle_build(robot, constants.unit_prophet)
+                    return castles_utility._castle_build(robot, constants.unit_crusader)
                 else:
                     robot.pilgrim_build_number += 1
                     temp_store = castles_utility._castle_assign_mine_or_scout(robot)
@@ -70,9 +70,9 @@ def _build_manager_castle(robot):
                 # elif (preacher_count * 2) < crusader_count:
                 #     # robot.signal(robot.me.signal + 1, 2)
                 #     return castle_build(robot, constants.unit_preacher)
-                if prophet_count < pilgrim_count and robot.step > 60 and robot.fuel > 600:
+                if crusader_count < pilgrim_count and robot.step > 60 and robot.fuel > 600:
                     robot.signal(1, 2)
-                    return castles_utility._castle_build(robot, constants.unit_prophet)
+                    return castles_utility._castle_build(robot, constants.unit_crusader)
                 if pilgrim_count < (total_fuel + total_karbonite) * .55:
                     robot.pilgrim_build_number += 1
                     temp_store = castles_utility._castle_assign_mine_or_scout(robot)
@@ -83,17 +83,17 @@ def _build_manager_castle(robot):
                         robot.signal(65534, 2)
                 elif robot.step > 300 and robot.karbonite > 600 and robot.fuel > 600:
                     robot.signal(1, 2)
-                    return castles_utility._castle_build(robot, constants.unit_prophet)
+                    return castles_utility._castle_build(robot, constants.unit_crusader)
                 elif robot.step > 500 and robot.step < 800 and robot.karbonite > 300 and robot.fuel > 300:
                     robot.signal(1, 2)
-                    return castles_utility._castle_build(robot, constants.unit_prophet)
+                    return castles_utility._castle_build(robot, constants.unit_crusader)
                 elif robot.step >= 800:
                     #TODO At war change production status
                     robot.signal(1, 2)
                     return castles_utility._castle_build(robot, constants.unit_crusader)
-        elif prophet_count < 2 and robot.karbonite >= 25 and robot.step < 10:
-            robot.signal(1, 2)
-            return castles_utility._castle_build(robot, constants.unit_prophet)
+        # elif prophet_count < 2 and robot.karbonite >= 25 and robot.step < 10:
+        #     robot.signal(1, 2)
+        #     return castles_utility._castle_build(robot, constants.unit_crusader)
 
 def _build_manager_church(robot):
     pos_x = robot.me.x
@@ -104,7 +104,7 @@ def _build_manager_church(robot):
         for direction in directions:
             if (not utility.is_cell_occupied(occupied_map, pos_x + direction[1],  pos_y + direction[0])) and passable_map[pos_y + direction[0]][pos_x + direction[1]] == 1:
                 # TRAVIS BUILD CHECK 4
-                return check.build_check(robot, constants.unit_prophet, direction[1], direction[0], 4)
+                return check.build_check(robot, constants.unit_crusader, direction[1], direction[0], 4)
 
     # robot.log("No space to build units anymore for churches")
     return None
diff --git a/28.SeedBot/tactics.py b/28b.CrusaderBot_for_analysis/tactics.py
index 0956d47..2405a4b 100644
--- a/28.SeedBot/tactics.py
+++ b/28b.CrusaderBot_for_analysis/tactics.py
@@ -110,8 +110,6 @@ def send_combat_unit_to_battle_front(robot, ratio: float, delta: float):
     dest = robot.current_move_destination
     pos_x, pos_y = robot.me.x, robot.me.y
     passable_map, occupied_map, karb_map, fuel_map = utility.get_all_maps(robot)
-    if robot.me.id == 1037:
-        robot.log("Current pos: " + str((pos_x, pos_y)))
 
     if robot.lattice_dest and (pos_x + pos_y)%2 == 0:
     # if robot.lattice_dest and str((pos_x, pos_y)) == str(robot.current_move_destination):
@@ -126,7 +124,6 @@ def send_combat_unit_to_battle_front(robot, ratio: float, delta: float):
         return None
     if not robot.vertical_ratio_satisfied:
         is_combat_unit_at_front = utility.distance_ratio(robot, dest, ratio, delta)
-
         if is_combat_unit_at_front:
             robot.vertical_ratio_satisfied = True
             if (pos_x + pos_y)%2 == 0:
diff --git a/28.SeedBot/utility.py b/28b.CrusaderBot_for_analysis/utility.py
index abd626c..2295992 100644
--- a/28.SeedBot/utility.py
+++ b/28b.CrusaderBot_for_analysis/utility.py
@@ -163,6 +163,9 @@ def distance_ratio(robot, destination: tuple,
     start_to_cur = distance(robot, (pos_x, pos_y), robot.our_castle_or_church_base)
     destination_to_cur = distance(robot, (pos_x, pos_y), destination)
     ratio = start_to_cur/(destination_to_cur + start_to_cur)
+    if robot.me.id == 1037:
+        robot.log("Ratio is: " + str(ratio) + ", diff: " + str(abs(ratio-expected_ratio)))
+        robot.log("Ratios are: %d, %d"%(start_to_cur, destination_to_cur))
     ans = True if abs(ratio-expected_ratio) <= delta else False
     # robot.log("Outcome: " + str(ans))
     return ans
diff --git a/28.SeedBot/castles.py b/28b.CrusaderBot_for_analysis/castles.py
index bfc8565..8fa9ae7 100644
--- a/28.SeedBot/castles.py
+++ b/28b.CrusaderBot_for_analysis/castles.py
@@ -50,6 +50,7 @@ def castle(robot):
 def _castle_initial_check(robot):
     my_x = robot.me['x']
     my_y = robot.me['y']
+    robot.log(str((my_x, my_y)))
     if len(robot.fuel_mine_locations_from_this_castle) == 0:
         unused_store, robot.fuel_mine_locations_from_this_castle = utility.get_sorted_list_from_a_point(my_x, my_y, mapping.get_friendly_fuel(robot))
         robot.fuel_mine_occupancy_from_this_castle = [-1 for i in range(len(robot.fuel_mine_locations_from_this_castle))]
diff --git a/28.SeedBot/check.py b/28b.CrusaderBot_for_analysis/check.py
index 2b690b5..33f6757 100644
--- a/28.SeedBot/check.py
+++ b/28b.CrusaderBot_for_analysis/check.py
@@ -22,7 +22,9 @@ def move_check(robot, dx, dy, flag):
             if robot.fuel >= constants.prophet_move_fuel_cost * distance:
                 return robot.move(dx, dy)
         else:
-            robot.log("Move check failed " +  str(flag))
+            # robot.log(constants.crusader_speed)
+            # robot.log(str(dx, dy))
+            # robot.log("Move check failed " +  str(flag))
             return None
     if robot.me.unit == constants.unit_preacher:
         if distance <= constants.prophet_speed:
diff --git a/28.SeedBot/churches.py b/28b.CrusaderBot_for_analysis/churches.py
index e62c972..6a25636 100644
--- a/28.SeedBot/churches.py
+++ b/28b.CrusaderBot_for_analysis/churches.py
@@ -16,7 +16,7 @@ def church(robot):
         return production_module.default_production_order(robot)
     elif robot.step > 250 and robot.karbonite > 100 and robot.fuel > 200:
         robot.signal(1, 2)
-        return churches_utility.church_build(robot, constants.unit_prophet)
+        return churches_utility.church_build(robot, constants.unit_crusader)
     else:
         None
         # self.log("Castle health: " + self.me['health'])
diff --git a/28.SeedBot/churches_utility.py b/28b.CrusaderBot_for_analysis/churches_utility.py
index 6ab2ba0..012154f 100644
--- a/28.SeedBot/churches_utility.py
+++ b/28b.CrusaderBot_for_analysis/churches_utility.py
@@ -9,6 +9,8 @@ def recieve_initial_signal(robot):
     for friendly_unit in friendly_units:
         if friendly_unit.unit == 2 and friendly_unit.signal > 0:
             _prophets_initial_check(robot, friendly_unit)
+        elif friendly_unit == 3 and friendly_unit.signal > 0:
+            _prophets_initial_check(robot, friendly_unit)
             break
 
 def _prophets_initial_check(robot, friendly_unit):
diff --git a/28.SeedBot/combat_module.py b/28b.CrusaderBot_for_analysis/combat_module.py
index 06a34bd..13bc5d9 100644
--- a/28.SeedBot/combat_module.py
+++ b/28b.CrusaderBot_for_analysis/combat_module.py
@@ -92,6 +92,7 @@ def _prophet_combat(robot):
         else:
             # TRAVIS ATTACK CHECK 15
             return combat_utility.attack_location(robot, enemy_unit['x'], enemy_unit['y'], 15, fuel, enemy_unit)
+    return None
 
 def _crusader_combat(robot):
     # combat_utility.fill_combat_map(robot)
@@ -108,9 +109,17 @@ def _crusader_combat(robot):
         # Give resources to church/castle/pilgrim/unit via convoy
         return None
 
+    if robot.delta_health_reduced != 0 and robot.step != 0:
+        robot.guessing_in_direction = (robot.me.x - robot.position_at_end_of_turn[0], robot.me.y - robot.position_at_end_of_turn[1])
+        robot.position_at_end_of_turn = 3
+    elif robot.delta_health_reduced == 0 and robot.position_at_end_of_turn != 0:
+        robot.position_at_end_of_turn -= 1
+
     # Attacked by out-of-vision enemy unit
-    if len(visible_enemy_list) == 0 and robot.delta_health_reduced != 0 and robot.step != 0:
-        None
+    if len(visible_enemy_list) == 0 and robot.step != 0 and (robot.delta_health_reduced != 0 or robot.position_at_end_of_turn != 0):
+        guess_enemy_direction_and_move = combat_utility.enemy_direction_guess_and_move(robot, visible_friendly_distance, visible_friendly_list)
+        if guess_enemy_direction_and_move != None:
+            return guess_enemy_direction_and_move
 
     # We see an enemy
     if len(visible_enemy_list) != 0:
@@ -125,7 +134,7 @@ def _crusader_combat(robot):
         closest_pos = combat_utility.give_crusader_charge_location(robot, visible_enemy_list, visible_enemy_distance)
         if closest_pos != None:
             # TRAVIS MOVE CHECK 20
-            return check.move_check(robot, closest_pos[0], closest_pos[1], 20)
+            return check.move_check(robot, closest_pos[0] - robot.me.x, closest_pos[1] - robot.me.y, 20)
 
 def _preacher_combat(robot):
     combat_utility.fill_combat_map(robot)
diff --git a/28.SeedBot/combat_utility.py b/28b.CrusaderBot_for_analysis/combat_utility.py
index 6027abb..5da35fb 100644
--- a/28.SeedBot/combat_utility.py
+++ b/28b.CrusaderBot_for_analysis/combat_utility.py
@@ -1,5 +1,6 @@
 import check
 import constants
+import pathfinding
 import utility
 import vision
 
@@ -222,6 +223,29 @@ def give_crusader_charge_location(robot, visible_enemy_list, visible_enemy_dista
                         closest_pos = (new_pos_x, new_pos_y)
     return closest_pos
 
+def enemy_direction_guess_and_move(robot, visible_friendly_distance, visible_friendly_list):
+    passable_map, occupied_map, karb_map, fuel_map = utility.get_all_maps(robot)
+    pos_x = robot.me.x
+    pos_y = robot.me.y
+    dirc_x, dirc_y = robot.guessing_in_direction
+    if len(visible_friendly_list) != 0:
+        fin_dir = pathfinding.bug_walk_toward(passable_map, occupied_map, pos_x + dirc_x, pos_y + dirc_y, pos_x, pos_y)
+        if fin_dir != 0:
+            # TRAVIS MOVE CHECK 21
+            return check.move_check(robot, fin_dir[0], fin_dir[1], 21)
+        else:
+            return None
+    else:
+        fin_dir = pathfinding.bug_walk_toward(passable_map, occupied_map, pos_x - dirc_x, pos_y - dirc_y, pos_x, pos_y)
+        if fin_dir != 0:
+            # TRAVIS MOVE CHECK 22
+            return check.move_check(robot, fin_dir[0], fin_dir[1], 22)
+        else:
+            return None
+    return None
+
+
+
 def give_stats(unit):
     if unit['unit'] == constants.unit_castle:
         return _give_castle_stats()
diff --git a/28.SeedBot/crusaders.py b/28b.CrusaderBot_for_analysis/crusaders.py
index 26738ee..c63debf 100644
--- a/28.SeedBot/crusaders.py
+++ b/28b.CrusaderBot_for_analysis/crusaders.py
@@ -1,12 +1,18 @@
 import combat_module
+import constants
+import mapping
 import movement
 import tactics
+import vision
 
 def crusader(robot):
+    if robot.step == 0:
+        receive_initial_signal(robot)
 
-    prophet_attack_aggr_mode = combat_module.give_military_command(robot)
-    if prophet_attack_aggr_mode != None:
-        return prophet_attack_aggr_mode
+
+    crusader_attack_aggr_mode = combat_module.give_military_command(robot)
+    if crusader_attack_aggr_mode != None:
+        return crusader_attack_aggr_mode
 
     return crusader_move(robot)
 
@@ -14,3 +20,36 @@ def crusader_move(robot):
     if robot.current_move_destination != None and not movement.is_completely_surrounded(robot): #and tactics.should_combat_unit_be_at_battle_front(robot):
         return tactics.send_combat_unit_to_battle_front(robot, 0.35, 0.15)
     return 0
+
+def receive_initial_signal(robot):
+    unused_store, friendly_units = vision.sort_visible_friendlies_by_distance(robot)
+    for friendly_unit in friendly_units:
+        if friendly_unit.unit == 0 and friendly_unit.signal > 0:
+            robot.built_by_a_castle = 1
+            robot.built_by_a_church = 0
+            _crusader_initial_check(robot, friendly_unit)
+        elif friendly_unit.unit == 1 and friendly_unit.signal > 0:
+            robot.built_by_a_castle = 0
+            robot.built_by_a_church = 1
+            _crusader_initial_check(robot, friendly_unit)
+            break
+
+def _crusader_initial_check(robot, friendly_unit):
+
+    if robot.built_by_a_castle == 1:
+        robot.our_castle_or_church_base = (friendly_unit['x'], friendly_unit['y'])
+        robot.friendly_castles.append(robot.our_castle_or_church_base)
+    else:
+        robot.our_castle_or_church_base = (friendly_unit['x'], friendly_unit['y'])
+        robot.friendly_churches.append(robot.our_castle_or_church_base)
+
+    if robot.crusader_health == None:
+        robot.crusader_health = constants.crusader_max_health
+
+    if robot.map_symmetry == None:
+        mapping.return_map_symmetry(robot)
+
+    if len(robot.enemy_castles) == 0 and robot.built_by_a_castle == 1:
+        robot.enemy_castles.append(mapping.find_symmetrical_point(robot, friendly_unit['x'], friendly_unit['y'], robot.map_symmetry))
+
+    robot.current_move_destination = mapping.find_symmetrical_point(robot, robot.our_castle_or_church_base[0], robot.our_castle_or_church_base[1], robot.map_symmetry)
diff --git a/28.SeedBot/production_module.py b/28b.CrusaderBot_for_analysis/production_module.py
index 291a1a6..c8d1dc4 100644
--- a/28.SeedBot/production_module.py
+++ b/28b.CrusaderBot_for_analysis/production_module.py
@@ -52,9 +52,9 @@ def _build_manager_castle(robot):
         # Peaceful Conditions
         if robot.step >= 3:
             if robot.karbonite >= 15 and robot.fuel > 100 and pilgrim_count < (total_fuel + total_karbonite) * .35 and robot.step < 60:
-                if prophet_count < pilgrim_count/2:
+                if crusader_count < pilgrim_count/2:
                     robot.signal(1, 2)
-                    return castles_utility._castle_build(robot, constants.unit_prophet)
+                    return castles_utility._castle_build(robot, constants.unit_crusader)
                 else:
                     robot.pilgrim_build_number += 1
                     temp_store = castles_utility._castle_assign_mine_or_scout(robot)
@@ -70,9 +70,9 @@ def _build_manager_castle(robot):
                 # elif (preacher_count * 2) < crusader_count:
                 #     # robot.signal(robot.me.signal + 1, 2)
                 #     return castle_build(robot, constants.unit_preacher)
-                if prophet_count < pilgrim_count and robot.step > 60 and robot.fuel > 600:
+                if crusader_count < pilgrim_count and robot.step > 60 and robot.fuel > 600:
                     robot.signal(1, 2)
-                    return castles_utility._castle_build(robot, constants.unit_prophet)
+                    return castles_utility._castle_build(robot, constants.unit_crusader)
                 if pilgrim_count < (total_fuel + total_karbonite) * .55:
                     robot.pilgrim_build_number += 1
                     temp_store = castles_utility._castle_assign_mine_or_scout(robot)
@@ -83,17 +83,17 @@ def _build_manager_castle(robot):
                         robot.signal(65534, 2)
                 elif robot.step > 300 and robot.karbonite > 600 and robot.fuel > 600:
                     robot.signal(1, 2)
-                    return castles_utility._castle_build(robot, constants.unit_prophet)
+                    return castles_utility._castle_build(robot, constants.unit_crusader)
                 elif robot.step > 500 and robot.step < 800 and robot.karbonite > 300 and robot.fuel > 300:
                     robot.signal(1, 2)
-                    return castles_utility._castle_build(robot, constants.unit_prophet)
+                    return castles_utility._castle_build(robot, constants.unit_crusader)
                 elif robot.step >= 800:
                     #TODO At war change production status
                     robot.signal(1, 2)
                     return castles_utility._castle_build(robot, constants.unit_crusader)
-        elif prophet_count < 2 and robot.karbonite >= 25 and robot.step < 10:
-            robot.signal(1, 2)
-            return castles_utility._castle_build(robot, constants.unit_prophet)
+        # elif prophet_count < 2 and robot.karbonite >= 25 and robot.step < 10:
+        #     robot.signal(1, 2)
+        #     return castles_utility._castle_build(robot, constants.unit_crusader)
 
 def _build_manager_church(robot):
     pos_x = robot.me.x
@@ -104,7 +104,7 @@ def _build_manager_church(robot):
         for direction in directions:
             if (not utility.is_cell_occupied(occupied_map, pos_x + direction[1],  pos_y + direction[0])) and passable_map[pos_y + direction[0]][pos_x + direction[1]] == 1:
                 # TRAVIS BUILD CHECK 4
-                return check.build_check(robot, constants.unit_prophet, direction[1], direction[0], 4)
+                return check.build_check(robot, constants.unit_crusader, direction[1], direction[0], 4)
 
     # robot.log("No space to build units anymore for churches")
     return None
diff --git a/28.SeedBot/robot.py b/28b.CrusaderBot_for_analysis/robot.py
index 7410686..25dcadd 100644
--- a/28.SeedBot/robot.py
+++ b/28b.CrusaderBot_for_analysis/robot.py
@@ -100,6 +100,8 @@ class MyRobot(BCAbstractRobot):
     previousturn_combat_map = None
 
     # Combat Units
+    has_taken_a_hit = 0
+    guessing_in_direction = None
     is_targeting_robot_with_id = None # Remember robot to kill, after current turn
     current_combat_move_destination = None
     last_attacked_location = None
diff --git a/28.SeedBot/tactics.py b/28b.CrusaderBot_for_analysis/tactics.py
index 0956d47..2405a4b 100644
--- a/28.SeedBot/tactics.py
+++ b/28b.CrusaderBot_for_analysis/tactics.py
@@ -110,8 +110,6 @@ def send_combat_unit_to_battle_front(robot, ratio: float, delta: float):
     dest = robot.current_move_destination
     pos_x, pos_y = robot.me.x, robot.me.y
     passable_map, occupied_map, karb_map, fuel_map = utility.get_all_maps(robot)
-    if robot.me.id == 1037:
-        robot.log("Current pos: " + str((pos_x, pos_y)))
 
     if robot.lattice_dest and (pos_x + pos_y)%2 == 0:
     # if robot.lattice_dest and str((pos_x, pos_y)) == str(robot.current_move_destination):
@@ -126,7 +124,6 @@ def send_combat_unit_to_battle_front(robot, ratio: float, delta: float):
         return None
     if not robot.vertical_ratio_satisfied:
         is_combat_unit_at_front = utility.distance_ratio(robot, dest, ratio, delta)
-
         if is_combat_unit_at_front:
             robot.vertical_ratio_satisfied = True
             if (pos_x + pos_y)%2 == 0:
diff --git a/28.SeedBot/utility.py b/28b.CrusaderBot_for_analysis/utility.py
index abd626c..2295992 100644
--- a/28.SeedBot/utility.py
+++ b/28b.CrusaderBot_for_analysis/utility.py
@@ -163,6 +163,9 @@ def distance_ratio(robot, destination: tuple,
     start_to_cur = distance(robot, (pos_x, pos_y), robot.our_castle_or_church_base)
     destination_to_cur = distance(robot, (pos_x, pos_y), destination)
     ratio = start_to_cur/(destination_to_cur + start_to_cur)
+    if robot.me.id == 1037:
+        robot.log("Ratio is: " + str(ratio) + ", diff: " + str(abs(ratio-expected_ratio)))
+        robot.log("Ratios are: %d, %d"%(start_to_cur, destination_to_cur))
     ans = True if abs(ratio-expected_ratio) <= delta else False
     # robot.log("Outcome: " + str(ans))
     return ans
